// Generated by CoffeeScript 1.10.0
var ProgressView, SortedCollection,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ProgressView = (function(superClass) {
  extend(ProgressView, superClass);

  function ProgressView() {
    this.updateFlot = bind(this.updateFlot, this);
    this.afterRender = bind(this.afterRender, this);
    return ProgressView.__super__.constructor.apply(this, arguments);
  }

  ProgressView.prototype.className = "ProgressView";

  ProgressView.prototype.INDIVIDUAL = 1;

  ProgressView.prototype.AGGREGATE = 2;

  ProgressView.prototype.events = {
    'click .back': 'goBack',
    'click .select_itemType': 'selectItemType',
    'click .xtick': 'selectAssessment'
  };

  ProgressView.prototype.selectAssessment = function(event) {
    this.selected.week = parseInt($(event.target).attr('data-index'));
    this.updateTable();
    return this.updateFlot();
  };

  ProgressView.prototype.selectItemType = function(event) {
    var $target;
    $target = $(event.target);
    this.selected.itemType = $target.attr('data-itemType');
    this.$el.find(".select_itemType").removeClass("selected");
    $target.addClass("selected");
    this.updateTable();
    return this.updateFlot();
  };

  ProgressView.prototype.goBack = function() {
    return history.go(-1);
  };

  ProgressView.prototype.initialize = function(options) {
    var data, dataForBenchmark, graphIndex, i, itemType, itemTypes, j, k, key, l, len, len1, len2, len3, len4, len5, len6, len7, m, n, name, o, p, part, partByIndex, parts, pointsByItemType, q, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, result, row, subtest, subtests, subtestsByPart;
    this.results = options.results;
    this.student = options.student;
    this.subtests = options.subtests;
    this.klass = options.klass;
    if (this.klass == null) {
      Utils.log(this, "No klass.");
    }
    if (this.subtests == null) {
      Utils.log(this, "No progress type subtests.");
    }
    if (this.results.length === 0) {
      this.renderReady = true;
      this.render();
      return;
    }
    this.mode = this.student != null ? this.INDIVIDUAL : this.AGGREGATE;
    this.subtestNames = {};
    this.benchmarkScore = {};
    this.rows = [];
    this.partCount = 0;
    this.flot = null;
    this.lastPart = Math.max.apply(this, _.compact(this.subtests.pluck("part")));
    this.resultsByPart = [];
    this.itemTypeList = {};
    this.selected = {
      "itemType": null,
      "week": 0
    };
    parts = [];
    ref = this.subtests.models;
    for (j = 0, len = ref.length; j < len; j++) {
      subtest = ref[j];
      if (!~parts.indexOf(subtest.get("part"))) {
        parts.push(subtest.get("part"));
      }
      i = parts.indexOf(subtest.get("part"));
      if (this.subtestNames[i] == null) {
        this.subtestNames[i] = {};
      }
      this.subtestNames[i][subtest.get("itemType")] = subtest.get("name");
    }
    this.partCount = parts.length;
    subtestsByPart = this.subtests.indexBy("part");
    partByIndex = _.keys(subtestsByPart);
    this.indexByPart = [];
    for (i = k = 0, len1 = partByIndex.length; k < len1; i = ++k) {
      part = partByIndex[i];
      this.indexByPart[part] = i;
    }
    this.resultsByPart = this.results.indexBy("part");
    ref1 = this.results.models;
    for (l = 0, len2 = ref1.length; l < len2; l++) {
      result = ref1[l];
      this.itemTypeList[result.get("itemType").toLowerCase()] = true;
    }
    this.itemTypeList = _.keys(this.itemTypeList);
    for (part = m = 1, ref2 = this.lastPart; 1 <= ref2 ? m <= ref2 : m >= ref2; part = 1 <= ref2 ? ++m : --m) {
      if (this.resultsByPart[part] === void 0) {
        continue;
      }
      itemTypes = {};
      ref3 = this.resultsByPart[part];
      for (i = n = 0, len3 = ref3.length; n < len3; i = ++n) {
        result = ref3[i];
        if (this.mode === this.INDIVIDUAL && result.get("studentId") !== this.student.id) {
          continue;
        }
        itemType = result.get("itemType");
        if (this.selected.itemType == null) {
          this.selected.itemType = itemType;
        }
        if (itemTypes[itemType] == null) {
          itemTypes[itemType] = [];
        }
        itemTypes[itemType].push({
          "name": itemType.titleize(),
          "key": itemType,
          "part": result.get("part"),
          "correct": result.get("correct"),
          "attempted": result.get("attempted"),
          "itemsPerMinute": result.getCorrectPerSeconds(60)
        });
        this.benchmarkScore[itemType] = this.subtests.get(result.get("subtestId")).getNumber("scoreTarget");
      }
      this.rows.push({
        "part": part,
        "itemTypes": _.values(itemTypes)
      });
    }
    this.rows = this.aggregate(this.rows);
    if (this.rows.length !== 0) {
      this.selected = {
        week: this.indexByPart[_.last(this.rows)['part']],
        itemType: _.last(this.rows)['itemTypes'][0].key
      };
    }
    pointsByItemType = {};
    ref4 = this.rows;
    for (i = o = 0, len4 = ref4.length; o < len4; i = ++o) {
      row = ref4[i];
      ref5 = row.itemTypes;
      for (p = 0, len5 = ref5.length; p < len5; p++) {
        itemType = ref5[p];
        graphIndex = this.indexByPart[row.part] + 1;
        if (pointsByItemType[itemType.key] == null) {
          pointsByItemType[itemType.key] = [];
        }
        pointsByItemType[itemType.key].push([graphIndex, itemType.itemsPerMinute]);
      }
    }
    this.flotData = [];
    this.benchmarkData = [];
    i = 0;
    for (name in pointsByItemType) {
      data = pointsByItemType[name];
      key = name.toLowerCase();
      this.flotData[key] = {
        "data": data,
        "label": name.titleize(),
        "key": key,
        "lines": {
          "show": true
        },
        "points": {
          "show": true
        }
      };
    }
    this.flotBenchmark = [];
    ref6 = this.subtests.indexBy("itemType");
    for (itemType in ref6) {
      subtests = ref6[itemType];
      dataForBenchmark = [];
      for (i = q = 0, len6 = subtests.length; q < len6; i = ++q) {
        subtest = subtests[i];
        graphIndex = this.indexByPart[subtest.get("part")] + 1;
        dataForBenchmark.push([graphIndex, subtest.getNumber("scoreTarget")]);
      }
      this.flotBenchmark[itemType.toLowerCase()] = {
        "label": "Progress benchmark",
        "data": dataForBenchmark,
        "color": "#aaa",
        "lines": {
          "show": true
        }
      };
    }
    this.warningThresholds = {};
    ref7 = this.subtests.indexBy("itemType");
    for (itemType in ref7) {
      subtests = ref7[itemType];
      this.warningThresholds[itemType] = [];
      for (i = r = 0, len7 = subtests.length; r < len7; i = ++r) {
        subtest = subtests[i];
        this.warningThresholds[itemType.toLowerCase()][this.indexByPart[subtest.get("part")]] = {
          target: subtest.getNumber("scoreTarget"),
          spread: subtest.getNumber("scoreSpread"),
          seconds: subtest.getNumber("timer")
        };
      }
    }
    this.renderReady = true;
    return this.render();
  };

  ProgressView.prototype.render = function() {
    var $window, html, htmlWarning, j, key, label, len, ref, selectedClass, studentName, win;
    if (!this.renderReady) {
      return;
    }
    $window = $(window);
    win = {
      h: $window.height(),
      w: $window.width()
    };
    if (this.mode === this.INDIVIDUAL) {
      studentName = "<h2>" + (this.student.get('name')) + "</h2>";
    }
    html = "<h1>Progress table</h1> " + (studentName || "");
    htmlWarning = "<p>No test data for this type of report. Return to the <a href='#class'>class menu</a> and click the <img src='images/icon_run.png'> icon to collect data.</p>";
    if (this.results.length === 0) {
      this.$el.html(html + " " + htmlWarning);
      this.trigger("rendered");
      return;
    }
    html += "<div id='flot-menu'>";
    ref = _.uniq(this.subtests.pluck("itemType"));
    for (j = 0, len = ref.length; j < len; j++) {
      key = ref[j];
      label = key.replace(/[_-]/g, " ").capitalize();
      selectedClass = key === this.selected.itemType ? "selected" : "";
      html += "<button class='command select_itemType " + selectedClass + "' data-itemType='" + key + "'>" + label + "</button>";
    }
    html += "</div> <div id='flot-container' style='width: " + (window.w * 0.8) + "px; height:300px;'></div>";
    html += "<div id='table_container'></div> <button class='navigation back'>" + (t('back')) + "</button>";
    this.$el.html(html);
    this.updateTable();
    return this.trigger("rendered");
  };

  ProgressView.prototype.afterRender = function() {
    return this.updateFlot();
  };

  ProgressView.prototype.updateTable = function() {
    var availableItemTypesThisWeek, data, datum, difference, high, html, i, itemType, j, k, l, len, len1, len2, low, ref, ref1, ref2, result, row, score, threshold, type, warnings, week;
    type = this.selected.itemType;
    week = this.selected.week;
    html = "<table class='tabular'>";
    ref = this.rows;
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      row = ref[i];
      if (!~_.pluck(row.itemTypes, "key").indexOf(type)) {
        continue;
      }
      html += "<tr><th>" + this.subtestNames[i][type] + "</th></tr><tr>";
      ref1 = row.itemTypes;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        itemType = ref1[k];
        if (itemType.key !== type) {
          continue;
        }
        html += "<tr> <td>" + itemType.name + " correct</td><td>" + itemType.correct + "/" + itemType.attempted + "</td> </tr> <tr> <td>" + itemType.name + " correct per minute</td><td>" + itemType.itemsPerMinute + "</td> </tr>";
      }
    }
    html += "</table>";
    availableItemTypesThisWeek = _.pluck((ref2 = this.rows[week]) != null ? ref2.itemTypes : void 0, "key");
    if (week >= this.rows.length || !~availableItemTypesThisWeek.indexOf(type)) {
      html += "<section>No data for this assessment.</section>";
    } else if (this.mode === this.AGGREGATE) {
      score = 0;
      data = this.flotData[type] != null ? this.flotData[type].data : [];
      for (l = 0, len2 = data.length; l < len2; l++) {
        datum = data[l];
        if (datum[0] === week + 1) {
          score = datum[1];
        }
      }
      threshold = this.warningThresholds[type][week];
      high = threshold.target + threshold.spread;
      low = threshold.target - threshold.spread;
      difference = score - threshold.target;
      if (score > high) {
        result = "(" + score + "), " + difference + " correct items per minute above the benchmark";
        warnings = "Your class is doing well, " + result + ", continue with the reading program. Share your and your class’ great work with parents. Reward your class with some fun reading activities such as reading marathons or competitions. However, look at a student grouping report for this assessment and make sure that those children performing below average get extra attention and practice and don’t fall behind.";
      } else if (score < low) {
        result = "(" + score + "), " + (Math.abs(difference)) + " correct items per minute below the benchmark";
        warnings = "Your class is performing below the grade-level target, " + result + ". Plan for additional lesson time focusing on reading in consultation with your principal. Encourage parents to spend more time with reading materials at home – remind them that you are a team working together to help their children learning to read. Think about organizing other events and opportunities for practice, e.g., reading marathons or competitions to motivate students to read more.";
      } else {
        if (difference !== 0 && difference * -1 === Math.abs(difference)) {
          result = (score - threshold.target) + " correct items per minute above the bench mark";
        } else if (difference === 0) {
          result = score + " correct items per minute";
        } else {
          result = ("(" + score + "), ") + Math.abs(score - threshold.target) + " correct items per minute below the bench mark";
        }
        warnings = "Your class is in line with expectations, " + result + ". Continue with the reading program and keep up the good work! Look at a student grouping report for this assessment and make sure that those children performing below average get extra attention and practice and don’t fall behind.";
      }
      html += "<section> " + warnings + " </section>";
    }
    return this.$el.find("#table_container").html(html);
  };

  ProgressView.prototype.updateFlot = function() {
    var displayData, i;
    this.flotOptions = {
      "xaxis": {
        "min": 0.5,
        "max": this.partCount + 0.5,
        "ticks": (function() {
          var j, ref, results1;
          results1 = [];
          for (i = j = 1, ref = this.partCount; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
            results1.push(String(i));
          }
          return results1;
        }).call(this),
        "tickDecimals": 0,
        "tickFormatter": (function(_this) {
          return function(num) {
            if (_this.subtestNames[num - 1][_this.selected.itemType] != null) {
              return "<button class='xtick " + (num - 1 === _this.selected.week ? 'selected' : '') + "' data-index='" + (num - 1) + "'>" + _this.subtestNames[num - 1][_this.selected.itemType] + "</button>";
            } else {
              return "";
            }
          };
        })(this)
      },
      "grid": {
        "markings": {
          "color": "#ffc",
          "xaxis": {
            "to": this.selected.week + 0.5,
            "from": this.selected.week - 0.5
          }
        }
      }
    };
    displayData = [];
    if (this.flotData[this.selected.itemType]) {
      displayData.push(this.flotData[this.selected.itemType]);
    }
    if (this.flotBenchmark[this.selected.itemType]) {
      displayData.push(this.flotBenchmark[this.selected.itemType]);
    }
    return this.flot = $.plot(this.$el.find("#flot-container"), displayData, this.flotOptions);
  };

  ProgressView.prototype.aggregate = function(oldRows) {
    var i, j, k, l, len, len1, len2, mean, newRows, ref, result, results, row;
    newRows = [];
    for (i = j = 0, len = oldRows.length; j < len; i = ++j) {
      row = oldRows[i];
      newRows[i] = {
        "part": row.part,
        "itemTypes": []
      };
      ref = row.itemTypes;
      for (k = 0, len1 = ref.length; k < len1; k++) {
        results = ref[k];
        mean = {
          "name": "",
          "key": "",
          "correct": 0,
          "attempted": 0,
          "itemsPerMinute": 0
        };
        for (l = 0, len2 = results.length; l < len2; l++) {
          result = results[l];
          mean.name = result.name;
          mean.key = result.key;
          mean.correct += result.correct;
          mean.attempted += result.attempted;
          mean.itemsPerMinute += result.itemsPerMinute;
        }
        mean.correct /= results.length;
        mean.attempted /= results.length;
        mean.itemsPerMinute /= results.length;
        mean.correct = Math.round(mean.correct);
        mean.attempted = Math.round(mean.attempted);
        mean.itemsPerMinute = Math.round(mean.itemsPerMinute);
        newRows[i].itemTypes.push(mean);
      }
    }
    return newRows;
  };

  return ProgressView;

})(Backbone.View);

SortedCollection = (function() {
  function SortedCollection(options) {
    this.sorted = [];
    this.models = options.models;
    this.attribute = options.attribute;
  }

  return SortedCollection;

})();
